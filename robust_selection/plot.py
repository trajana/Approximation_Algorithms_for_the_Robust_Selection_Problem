# plot.py

# Script to visualize the quality of the algorithms.

# Loads results from a .pkl file (generated by main.py), computes the average approximation ratio (ALG / OPT)
# for different values of n (number of items), and plots the ratio (and other metrics) with error bars.
# The plot helps evaluate how the performance of the algorithms scales with problem size.

# Plots are currently generated without titles (titles were added manually in LaTeX later). If you want titles,
# uncomment the relevant lines.

import math
import numpy as np
import os
import matplotlib
import matplotlib.pyplot as plt

# Global matplotlib settings for consistent styling
matplotlib.rcParams.update({
    "text.usetex": True,
    "font.family": "sans-serif",
    "font.sans-serif": ["Helvetica"],
    "axes.labelsize": 17,
    "font.size": 17,
    "legend.fontsize": 17,
    "xtick.labelsize": 17,
    "ytick.labelsize": 17,
    "grid.linestyle": ":",
    "grid.linewidth": 0.5,
    "grid.alpha": 0.4,
    "axes.grid": True,
    "figure.figsize": (10, 6)
})

matplotlib.rcParams["text.latex.preamble"] = r"""
\usepackage[T1]{fontenc}
\usepackage{helvet}
\usepackage{sansmath}
\sansmath
"""


COL = {
    "primal": "#000000",
    "primal_dual": "#000000",
    "midpoint": "#778899",
    "worst_case_p_item": "#778899",
}

STYLE = {
    "primal":              dict(linestyle="-",  marker="o"),
    "primal_dual":         dict(linestyle="--", marker="s"),
    "midpoint":            dict(linestyle="-.", marker="D"),
    "worst_case_p_item":   dict(linestyle=":",  marker="^"),
}


def _finite(arr):
    a = np.asarray(arr, dtype=float)
    return a[np.isfinite(a)]


def safe_mean(values):
    vals = _finite(values)
    if vals.size == 0:
        return math.nan
    return float(np.mean(vals))


def safe_ci95(values):
    vals = _finite(values)
    sample_size = vals.size
    if sample_size < 2:
        return 0.0
    return 1.98 * float(np.std(vals, ddof=1)) / math.sqrt(sample_size)


def plot_approx_ratio_only(all_results, num_runs, var_param, fixed_n=None, fixed_k=None, c_range=None,
                           output_dir="results"):
    param_suffix = f"_{var_param}" if var_param in {"n", "k", "p"} else ""
    output_plot = f"{output_dir}/plot_approx_ratio_only_{param_suffix}.png"
    if not all_results:
        print("No results to plot.")
        return
    alg_key = all_results[0].get("algorithm", "") if all_results else ""
    label_map = {
        "primal": r"Primal rounding",
        "primal_dual": r"Primal--dual rounding",
        "midpoint": r"Midpoint method",
        "worst_case_p_item": r"Worst-case per item",
    }
    base_label = label_map.get(alg_key, alg_key)
    method_label = rf"{base_label} $\mathrm{{ALG}} / \mathrm{{OPT}}_\mathrm{{IP}}$"
    color_line = COL.get(alg_key, "tab:gray")
    style = STYLE.get(alg_key, dict(linestyle="-", marker="o"))

    # Organize data by varying parameter (n, k, p)
    param_to_ratios = {}
    for entry in all_results:
        param = entry["varying_param"]
        ratio = entry["ratio_alg_opt"]
        param_to_ratios.setdefault(param, []).append(ratio)

    # Prepare data for plotting
    param_values = sorted(param_to_ratios.keys())
    avg_ratios = [safe_mean(param_to_ratios[param]) for param in param_values]
    ci_ratios_95 = [safe_ci95(param_to_ratios[param]) for param in param_values]
    fig = plt.figure()
    # Plot
    plt.errorbar(param_values, avg_ratios, yerr=ci_ratios_95, fmt='-o', capsize=5,
                 label=rf"{method_label} (Ø $\pm$ 95\% CI)", color=color_line)
    xlabel_map = {
        "n": r"Number of items $n$",
        "k": r"Number of scenarios $k$",
        "p": r"Number of items to select $p$"
    }
    plt.xlabel(xlabel_map.get(var_param, ""))
    plt.ylabel(r"Approximation ratio")
    # main_title = f"Primal Rounding Approximation Ratio {titles[criterion]} criterion"
    p_label = all_results[0]["p_label"] if all_results and "p_label" in all_results[0] else ""
    subtitle = (
            r"(Average over " + str(num_runs) + r" runs $\mid$ "
            + (r"$n$=" + str(fixed_n) + ", " if var_param != "n" and fixed_n is not None else "")
            + (r"$p$=" + p_label + ", " if var_param != "p" and p_label else "")
            + (r"$k$=" + str(fixed_k) + ", " if var_param != "k" and fixed_k is not None else "")
            + r"cost range: [1, " + str(c_range) + "])"
    )
    # plt.title(f"{main_title}\n{subtitle}")
    plt.title(subtitle)
    plt.xticks(param_values)
    plt.legend()
    plt.tight_layout()
    plt.savefig(output_plot, bbox_inches='tight')
    plt.close(fig)
    print(f"Plot saved to {output_plot}")


# def plot_approximation_ratios_primal(all_results, num_runs, var_param, fixed_n=None, fixed_k=None, c_range=None,
#                                      output_dir="results"):
#     param_suffix = f"_{var_param}" if var_param in {"n", "k", "p"} else ""
#     output_plot = f"{output_dir}/plot_ratio_{param_suffix}.png"
#
#     # Organize data by n
#     param_to_ratios = {}
#     param_to_bounds = {}
#     param_to_guarantee = {}
#     param_to_alg_div_optlp = {}
#     for entry in all_results:
#         param = entry["varying_param"]
#         ratio = entry["ratio_alg_opt"]
#         bound = entry["a_posteriori_bound"]
#         guarantee = entry["approximation_guarantee"]
#         alg_div_opt_lp = entry["alg_div_opt_lp"]
#         param_to_ratios.setdefault(param, []).append(ratio)
#         param_to_bounds.setdefault(param, []).append(bound)
#         param_to_guarantee.setdefault(param, []).append(guarantee)
#         param_to_alg_div_optlp.setdefault(param, []).append(alg_div_opt_lp)
#
#     # Prepare data for plotting
#     param_values = sorted(param_to_ratios.keys())
#     avg_guarantees = [np.mean(param_to_guarantee[p]) for p in param_values]
#     avg_ratios = [safe_mean(param_to_ratios[p]) for p in param_values]
#     ci_ratios_95 = [safe_ci95(param_to_ratios[p]) for p in param_values]
#     avg_bounds = [safe_mean(param_to_bounds[p]) for p in param_values]
#     ci_bounds_95 = [safe_ci95(param_to_bounds[p]) for p in param_values]
#     avg_alg_div_optlp = [safe_mean(param_to_alg_div_optlp[p]) for p in param_values]
#     ci_alg_div_optlp_95 = [safe_ci95(param_to_alg_div_optlp[p]) for p in param_values]
#
#     # Plot
#     plt.figure()
#     plt.errorbar(param_values, avg_ratios, yerr=ci_ratios_95, fmt='-o', capsize=5,
#                  label=r"Primal rounding $\mathrm{ALG} / \mathrm{OPT}_{\mathrm{IP}}$ (Ø $\pm$ 95\% CI)",
#                  color=COL["primal"])
#     plt.errorbar(param_values, avg_bounds, yerr=ci_bounds_95, fmt='--s', capsize=5,
#                  label=r"A posteriori bound $1/\tau$ (Ø $\pm$ 95\% CI)", color=COL["aposteriori_tau"])
#     plt.errorbar(param_values, avg_alg_div_optlp, yerr=ci_alg_div_optlp_95, fmt='-.d', capsize=5,
#                  label=r"A posteriori bound $\mathrm{ALG} / \mathrm{OPT}_{\mathrm{LP}}$ (Ø $\pm$ 95\% CI)",
#                  color=COL["aposteriori_lplb"])
#     plt.plot(param_values, avg_guarantees, ':^', label=r"Approximation guarantee $\min(k, n - p + 1)$",
#              color=COL["apriori"])
#     xlabel_map = {
#         "n": r"Number of items $n$",
#         "k": r"Number of scenarios $k$",
#         "p": r"Number of items to select $p$"
#     }
#     plt.xlabel(xlabel_map.get(var_param, ""))
#     plt.ylabel("Approximation ratio and bounds")
#     plt.yscale('log')
#     # main_title = f"Approximation Ratio vs. Approximation Guarantees for {titles[criterion]} criterion"
#     p_label = all_results[0].get("p_label", "") if all_results else ""
#     subtitle = (
#             r"(Average over " + str(num_runs) + r" runs $\mid$ "
#             + (r"$n$=" + str(fixed_n) + ", " if var_param != "n" and fixed_n is not None else "")
#             + (r"$p$=" + p_label + ", " if var_param != "p" and p_label else "")
#             + (r"$k$=" + str(fixed_k) + ", " if var_param != "k" and fixed_k is not None else "")
#             + r"cost range: [1, " + str(c_range) + "])"
#     )
#     # plt.title(f"{main_title}\n{subtitle}")
#     plt.title(subtitle)
#     plt.xticks(param_values)
#     plt.legend(loc='upper right', bbox_to_anchor=(1.0, 0.85))
#     plt.tight_layout()
#     plt.savefig(output_plot, bbox_inches='tight')
#     plt.close()
#     print(f"Plot saved to {output_plot}")
#
#
# def plot_approximation_ratios_primaldual(all_results, num_runs, var_param, fixed_n=None, fixed_k=None,
#                                          c_range=None, output_dir="results"):
#     param_suffix = f"_{var_param}" if var_param in {"n", "k", "p"} else ""
#     output_plot = f"{output_dir}/plot_ratio_primaldual_{param_suffix}.png"
#
#     # Organize data by param (e.g., n, k, or p)
#     param_to_ratios = {}
#     param_to_guarantee = {}
#     param_to_a_post = {}
#     param_to_alg_div_opt_lp = {}
#
#     for entry in all_results:
#         param = entry["varying_param"]
#         ratio = entry["ratio_alg_opt"]  # or "ratio_primaldual_opt" if that's what you use in results
#         guarantee = entry["approximation_guarantee"]
#         a_post = entry["a_posteriori_bound"]
#         alg_div_opt_lp = entry["alg_div_opt_lp"]
#         param_to_ratios.setdefault(param, []).append(ratio)
#         param_to_guarantee.setdefault(param, []).append(guarantee)
#         param_to_a_post.setdefault(param, []).append(a_post)
#         param_to_alg_div_opt_lp.setdefault(param, []).append(alg_div_opt_lp)
#
#     # Prepare data for plotting
#     param_values = sorted(param_to_ratios.keys())
#     avg_guarantees = [np.mean(param_to_guarantee[p]) for p in param_values]
#     avg_ratios = [safe_mean(param_to_ratios[p]) for p in param_values]
#     ci_ratios_95 = [safe_ci95(param_to_ratios[p]) for p in param_values]
#     avg_a_post = [safe_mean(param_to_a_post[p]) for p in param_values]
#     ci_bounds_95 = [safe_ci95(param_to_a_post[p]) for p in param_values]
#     avg_alg_div_opt_lp = [safe_mean(param_to_alg_div_opt_lp[p]) for p in param_values]
#     ci_alg_div_optlp_95 = [safe_ci95(param_to_alg_div_opt_lp[p]) for p in param_values]
#
#     # Plot
#     plt.figure()
#     plt.errorbar(param_values, avg_ratios, yerr=ci_ratios_95, fmt='-o', capsize=5,
#                  label=r"Primal-dual rounding $\mathrm{ALG} / \mathrm{OPT}_{\mathrm{IP}}$ (Ø $\pm$ 95\% CI)",
#                  color=COL["primal_dual"])
#     plt.plot(param_values, avg_guarantees, ':^',
#              label=r"Approximation guarantee $k$", color=COL["apriori"])
#     plt.errorbar(param_values, avg_a_post, yerr=ci_bounds_95, fmt='--s', capsize=5,
#                  label=r"A posteriori bound $\mathrm{ALG} / \mathrm{LB}_{\mathrm{dual}}$ (Ø $\pm$ 95\% CI)",
#                  color=COL["aposteriori_tau"])
#     plt.errorbar(param_values, avg_alg_div_opt_lp, yerr=ci_alg_div_optlp_95, fmt='--s', capsize=5,
#                  label=r"A posteriori bound $\mathrm{ALG} / \mathrm{OPT}_{\mathrm{LP}}$ (Ø $\pm$ 95\% CI)",
#                  color=COL["aposteriori_lplb"])
#
#     xlabel_map = {
#         "n": r"Number of items $n$",
#         "k": r"Number of scenarios $k$",
#         "p": r"Number of items to select $p$"
#     }
#     plt.xlabel(xlabel_map.get(var_param, ""))
#     plt.ylabel("Approximation ratio and bounds")
#     plt.yscale('log')
#     # main_title = f"Approximation Ratio vs. Approximation Guarantees for {titles[criterion]} criterion"
#     p_label = all_results[0].get("p_label", "") if all_results else ""
#     subtitle = (
#             r"(Average over " + str(num_runs) + r" runs $\mid$ "
#             + (r"$n$=" + str(fixed_n) + ", " if var_param != "n" and fixed_n is not None else "")
#             + (r"$p$=" + p_label + ", " if var_param != "p" and p_label else "")
#             + (r"$k$=" + str(fixed_k) + ", " if var_param != "k" and fixed_k is not None else "")
#             + r"cost range: [1, " + str(c_range) + "])"
#     )
#     # plt.title(f"{main_title}\n{subtitle}")
#     plt.title(subtitle)
#     plt.xticks(param_values)
#     plt.legend(loc='upper right', bbox_to_anchor=(1.0, 0.85))
#     plt.tight_layout()
#     plt.savefig(output_plot, bbox_inches='tight')
#     plt.close()
#     print(f"Plot saved to {output_plot}")


def plot_ratio_comp(results_by_alg, num_runs, var_param, fixed_n=None, fixed_k=None, c_range=None,
                    output_dir="results"):

    param_suffix = f"_{var_param}" if var_param in {"n", "k", "p"} else ""
    output_plot = f"{output_dir}/plot_ratio_comparison{param_suffix}.png"

    if not results_by_alg:
        print("No results to compare.")
        return

    label_map = {
        "primal": r"Primal rounding",
        "primal_dual": r"Primal--dual rounding",
        "midpoint": r"Midpoint method",
        "worst_case_p_item": r"Worst-case per item",
    }

    def collect_ratio_by_param(all_results):
        d = {}
        for e in all_results:
            p = e["varying_param"]
            r = e.get("ratio_alg_opt", math.nan)
            d.setdefault(p, []).append(r)
        return d

    # Collect all params across all algorithms
    per_alg = {alg: collect_ratio_by_param(res) for alg, res in results_by_alg.items()}
    all_params = sorted(set().union(*[set(d.keys()) for d in per_alg.values()]))

    if not all_params:
        print("No x-values found.")
        return

    plt.figure()

    # Plot each algorithm
    for alg, d in per_alg.items():
        avg = [safe_mean(d.get(p, [])) for p in all_params]
        err = [safe_ci95(d.get(p, [])) for p in all_params]

        plt.errorbar(
            all_params, avg, yerr=err, capsize=5,
            color=COL.get(alg, "tab:gray"),
            **STYLE.get(alg, dict(linestyle="-", marker="o")),
            label=rf"{label_map.get(alg, alg)}"
        )

    xlabel_map = {
        "n": r"Number of items $n$",
        "k": r"Number of scenarios $k$",
        "p": r"Number of items to select $p$"
    }
    plt.xlabel(xlabel_map.get(var_param, ""))
    plt.ylabel(r"Approximation ratio $\mathrm{{ALG}}/\mathrm{{OPT}}_\mathrm{{IP}}$ (Ø $\pm$ 95\% CI)")

    # # subtitle
    # any_res = next(iter(results_by_alg.values()))
    # p_label = any_res[0].get("p_label", "") if any_res else ""
    # subtitle = (
    #     r"(Average over " + str(num_runs) + r" runs $\mid$ "
    #     + (r"$n$=" + str(fixed_n) + ", " if var_param != "n" and fixed_n is not None else "")
    #     + (r"$p$=" + p_label + ", " if var_param != "p" and p_label else "")
    #     + (r"$k$=" + str(fixed_k) + ", " if var_param != "k" and fixed_k is not None else "")
    #     + r"cost range: [1, " + str(c_range) + "])"
    # )
    #plt.title(subtitle)

    plt.xticks(all_params)

    plt.legend(loc="best")
    plt.tight_layout()
    plt.savefig(output_plot, bbox_inches="tight")

    plt.close()

    print(f"Plot saved to {output_plot}")